## MySQL(10.1~10.7)

> MySQL执行过程

1. 连接器判断用户身份以及用户权限
2. 查询缓存，缓存命中直接返回（5.6版本默认关闭，8.0版本删除）
3. 分析器针对SQL语句进行分析，包括预处理和解析过程
4. 优化器针对SQL进行优化，并针对全表扫描以及能使用的索引进行计算，选择成本最佳的执行方案（I/O成本+CPU成本最小）
5. 执行器调用存储引擎的api执行SQL

> MySQL的数据结构

+ File Header：页的通用信息
+ Page Header：数据页专有的信息
+ Infimum & Supremum Records：记录当前页的最大、最小记录
+ User Records：实际存储的行记录的内容
+ Free Space：页中尚未使用的空间
+ Page Directory：页中的某些记录的相对位置（MySQL新增数据时会创建对应的Slot，一个Slot包含多条记录，借助Slot可实现二分查找记录）
+ File Tailer：校验页是否完整

> redo日志日志序列号（Log Sequeue Number /）

+  lsn：随着redo日志的不断增加，为了记录写入的redo日志的量设计了一个日志序列号的全局变量，初始值为8704，lsn越小，说明日志越早产生

+ flushed _to_disk_lsn：标记当前logbuffer中已经有哪些日志被刷新到磁盘中（redo日志先写到logbuffer中，之后才会刷新到磁盘）

+ checkpoint_lsn：标记当前系统中可以被覆盖的redo日志总量，初始值为8704（redo日志文件组容量有限，会循环使用redo日志文件，checkpoint_lsn之前的redo日志可以额比覆盖掉）

  ~~~txt
  checkpoint_lsn之前的日志对应的脏页已经被刷新到磁盘，所以checkpoint_lsn之前的日志文件中的内容可以被覆盖
  checkpoint_lsn~flushed_to_disk_lsn之间的日志已经从logbuffer刷新到日志文件中，但是脏页还不能确定有没有被刷盘
  flushed_to_disk_lsn~lsn之间的redo日志还留在log bugger中，redo日志没有刷新到文件，并且脏页没有被刷新到磁盘
  ~~~

> 恢复时如何知道某个redo日志对应的脏页是都在系统崩溃时已经刷盘

​	File Header中包含FIL_PAGE_LSN的属性，该属性记载了最近一次修改页面时对应的lsn值，如果在做了某次checkpoint后有脏页刷盘，那么该页对应的FIL_PAGE_LSN代表的lsn值肯定大于checkpoint_lsn值，凡是符合这种情况的页面就不需要重复执行lsn值小于FIL_PAGE_LSN的redo日志。

> Buffer Pool

​	数据库的一个内存组件，里面缓存了磁盘上的真实数据，对数据库的增删改查操作都是对buffer pool中的数据进行操作

+ Free Page：未被使用的页，位于Free链表
+ Clean Page：已被使用的页，但页内数据没有被修改，位于LRU链表
+ Dirty Page：已被使用且页内数据被修改，页内数据与磁盘数据不一致（脏页数据被写入磁盘后变为Clean Page），位于LRU链表和Flush链表
+ Free List：记录空闲页面（每次加载数据到内存中，会判断Free链表页面是否够用，不够则flush LRU链表和Flush链表释放空闲页，够则从Free链表中删除并添加到LRU链表中）
+ LRU List：记录在使用中的页并选择将哪些数据进行淘汰（分为Young链表/热数据区和Old链表/冷数据区，新读取的页添加在Old链表的头部，频繁访问的页会往Young链表的头部移动，最终Old链表尾部的页面将被淘汰）
+ Flush List：记录脏页数据（由后台线程Page Cleaner从尾部开始扫描执行flush操作）

> 脏页刷新条件

+ redo日志快满的时候（redo日志对应的脏数据还没有被写入磁盘就被覆盖掉的话，程序崩溃时无法进行数据恢复）
+ 为了保证MySQL中的空闲页面的数量（从LRU尾部淘汰一部分页面作为空闲页时，如果是脏页就需要先将页面flush到磁盘）
+ 脏页太多（脏页数量到达一定比例时默认75%会强制进行刷页保证系统有足够的Free Page）
+ MySQL正常关闭时也会把内存中的脏页全部刷新到磁盘

> InnoDB锁类型

+ 锁的属性分类：共享锁/读锁/S锁、排他锁/写锁/X锁
  + 共享锁：支持并发的读取数据，读取数据时不支持修改，避免出现重复读问题
  + 排他锁：在数据修改时候不允许其他人同时修改，也不允许其他人读取，避免了出现脏数据和脏读问题。
+ 锁的粒度分类：表级锁、行级锁
  + 表锁：SQL语句没有使用索引时会进行全表扫描，使用表锁锁定整张表
  + 行锁：锁住的是表的某一行或者多行记录（记录锁、间隙锁、临键锁）
    + 记录锁：锁住表中的某一条记录（精准条件命中且命中的条件字段时唯一索引）
    + 间隙锁：Gap锁，锁住表记录的某一段左开右开区间（插入意向锁也是间隙锁，在insert操作中产生，不阻止任何锁，和Gap锁冲突）
    + 临键锁：Next-key锁，记录锁+间隙锁（左开右闭区间）
+ 锁的状态分类：意向共享锁、意向排他锁
  + 属于表级锁，用于记录当前表是否已经有记录被添加上共享锁或排他锁，意向锁之间不冲突

## Redis(10.8~10.16)



## Java(10.17~10.23)



## Spring(10.24~10.30)



## Kafka+RocketMQ(10.31~11.6)



## Zookeeper+Nacos(11.7~11.13)



## Dubbo(11.14~11.20)



## Spring Cloud(11.21~11.27)



## Seata(11.28~12.4)



## Netty(12.5~12.11)



## 汇总(12.12~12.31)

